# Data Fetching 
  
  배우게 될것 
1. 서버 컴포넌트를 사용하여 서버에서 데이터를 가져옵니다.  
2. 데이터를 병렬로 가져오면 워터폴을 최소화하고 로딩 시간을 줄일 수 있습니다.  
3. 레이아웃 및 페이지의 경우 데이터가 사용되는 곳에서 데이터를 가져옵니다.  
Next.js는 트리에서 요청을 자동으로 중복 제거합니다.  
4. 로딩 UI, 스트리밍 및 서스펜스를 사용하여 페이지를 점진적으로  
렌더링하고 나머지 콘텐츠가 로드되는 동안 사용자에게 결과를 표시합니다.   
  
 #### fetch() API 
 
 
  서버에서 데이터 가져오기  
  
가능하면 서버 컴포넌트에서 데이터를 가져오는 것이 좋습니다.     
장점  
1. 백엔드 데이터 리소스(예: 데이터베이스)에 직접 접근할 수 있습니다.  
2. 액세스 토큰 및 API 키와 같은 민감한 정보가 클라이언트에 노출되는 것을 방지하여 애플리케이션을 더욱 안전하게 보호할 수 있습니다.  
3. 동일한 환경에서 데이터 가져오기 및 렌더링. 이렇게 하면 클라이언트와 서버 간의 주고받는 통신은 물론 클라이언트의 메인 스레드 작업도 줄어듭니다.  
4. 클라이언트에서 여러 번의 개별 요청 대신 한 번의 왕복으로 여러 데이터 가져오기를 수행합니다.  
5. 클라이언트-서버 워터폴 감소.??  
6. 위치에 따라 데이터 가져오기를 데이터 소스와 더 가까운 곳에서 수행하여 지연 시간을 줄이고 성능을 개선할 수도 있습니다.  
 
컴포넌트 레벨에서 데이터 가져오기  
앱 라우터에서는 레이아웃, 페이지 및 컴포넌트 내부의 데이터를 가져올 수 있습니다.   
데이터 가져오기는 스트리밍 및 서스펜스와도 호환됩니다.  

알아두면 좋습니다:  
레이아웃의 경우 상위 레이아웃과 하위 컴포넌트 간에 데이터를 전달할 수 없습니다.  
  
    
    
 ### 병렬 및 순차 데이터 불러오기  
컴포넌트 내부에서 데이터를 가져올 때 두 가지 데이터 가져오기 패턴을 알아야 합니다  
병렬과 순차입니다.  
![image](https://user-images.githubusercontent.com/99688960/237000559-767da4d1-0ca7-4373-a2af-053a855fb5d0.png)  
왼쪽 직렬 오른쪽 병렬  

병렬:  
병렬 데이터 가져오기를 사용하면 경로의 요청이 동시에 시작되고 동시에 데이터를 로드합니다.  
따라서 클라이언트-서버 워터폴과 데이터를 로드하는 데 걸리는 총 시간이 줄어듭니다.  
  
순차:   
순차적 데이터 가져오기를 사용하면 경로의 요청이 서로 종속되어 워터폴을 생성합니다.  
한 가져오기가 다른 가져오기의 결과에 의존하거나 리소스를 절약하기 위해  
다음 가져오기 전에 조건이 충족되기를 원하기 때문에 이 패턴을 원하는 경우가 있을 수 있습니다.  
그러나 이 동작은 의도치 않게 발생하여 로딩 시간이 길어질 수도 있습니다.   

#### 자동 fetch() Request 중복   

트리의 여러 컴포넌트에서 동일한 데이터(예: current user)를 가져와야 하는 경우,  
Next.js는 동일한 입력이 있는 가져오기 요청(GET)을 임시 캐시에 자동으로 캐싱합니다.  
이 최적화를 통해 렌더링 패스 중에 동일한 데이터를 두 번 이상 가져오는 것을 방지할 수 있습니다. (동일 입력 자동캐시하여 중복으로 가져오는 것을 방지) 


![image](https://user-images.githubusercontent.com/99688960/237001835-accebf13-d12b-47ba-8843-8259e824f0f3.png)  
  
 1. 서버에서 캐시는 렌더링 프로세스가 완료될 때까지 서버 요청의 수명 동안 지속됩니다.  
2. 이 최적화는 레이아웃, 페이지, 서버 컴포넌트, 생성 메타데이터 및 생성 정적 매개변수에서 이루어진 가져오기 요청에 적용됩니다.  
3. 이 최적화는 정적 생성 중에도 적용됩니다.  
4. 클라이언트에서 캐시는 전체 페이지가 다시 로드되기 전에 세션(여러 클라이언트 측 재렌더링이 포함될 수 있음) 동안 지속됩니다.   

#### 정적 및 동적 데이터 가져오기   
데이터에는 두 가지 유형이 있습니다: 정적 데이터와 동적 데이터입니다.  
![image](https://user-images.githubusercontent.com/99688960/237002779-0f0056cd-6eaf-406e-9207-aeec002e130f.png)  
왼 동적 우 정적  
기본적으로 Next.js는 정적 가져오기를 자동으로 수행합니다.   
즉, 빌드 시점에 데이터를 가져와서 캐시한 후 각 요청에 재사용합니다  
   
     
#### 정적 데이터를 사용하면 두 가지 이점  

1. 요청 횟수를 최소화하여 데이터베이스의 부하를 줄일 수 있습니다.  
2. 데이터는 자동으로 캐시되어 로딩 성능이 향상됩니다.  
  
  데이터가 사용자에게 맞춤화되어 있거나 항상 최신 데이터를 가져오려는 경우  
  요청을 동적으로 표시하고 캐싱하지 않고 각 요청에서 데이터를 가져올 수 있습니다.  
  데이터 캐싱  
캐싱은 데이터를 특정 위치(예: 콘텐츠 전송 네트워크)에 저장하여 요청할 때마다  
원본 소스에서 다시 가져올 필요가 없도록 하는 프로세스입니다.  
(평소 캐시 삭제에 쓰이던 것)  
![image](https://user-images.githubusercontent.com/99688960/237003491-ff524268-369b-4776-a8ec-627037bd474e.png)  

Next.js는 fetch() 함수의 옵션 객체를 확장하여 서버의 각 요청이 자체적인 영구 캐싱 동작을 설정할 수 있도록 합니다 .  
컴포넌트 레벨 데이터 가져오기와 함께 이를 통해 데이터가 사용되는 애플리케이션 코드 내에서 직접 캐싱을 구성할 수 있습니다.   
  
  서버 렌더링ing => 가져올 수 있는 캐시인지 확인 => 가능한 경우 캐시 데이터를 반환=> 그렇지 않은경우 가져와 저장.(쓰일지 모르기떄문?)  
#### Revalidating Data(데이터 재검증)  
재검증은 캐시를 지우고 최신 데이터를 다시 가져오는 프로세스.  
데이터 변경시 리빌드하지않고 가져올 수 있게 하는 것  

  
  Next.js는 두 가지 유형의 재검증을 제공합니다:  

백그라운드: 특정 시간 간격으로 데이터를 재검증합니다.  (시간)
온디맨드: 업데이트가 있을 때마다 데이터의 유효성을 재검증합니다.(종속성?)  

  
####  스트리밍 및 서스펜스
스트리밍과 서스펜스는 UI의 렌더링된 단위를 점진적으로 렌더링??? 하고  
클라이언트에 점진적으로 스트리밍할 수 있는 새로운 React 기능입니다.  
![image](https://user-images.githubusercontent.com/99688960/237004491-e9990772-97d6-4aac-9496-8d36671382f4.png)  








# Caching Data  
![image](https://github.com/ddp-study/nextjs/assets/99688960/48d38850-45e8-49b6-9491-be74a7421eb0)  
  
  요청별 캐싱  
#### fetch()  
기본적으로 모든 fetch() 요청은 캐시되고 자동으로 중복 제거됩니다.  
즉, 동일한 요청을 두 번 수행하면 두 번째 요청은 첫 번째 요청의 결과를 재사용합니다.  
![image](https://github.com/ddp-study/nextjs/assets/99688960/a59fcc10-1252-4e90-bd95-7454904eb8af)  


다음과 같은 경우 요청이 캐시되지 않습니다:  

1. 동적 메서드((next/headers, export const POST, or similar)가 사용되는 경우  
2. 페치가 POST 요청인 경우(또는 권한 부여 또는 쿠키 헤더를 사용하는 경우)  
3. fetchCache가 기본적으로 캐시를 건너뛰도록 구성됨  
4. 재검증: 0 또는 캐시: '저장 없음'이 개별 페치에 구성됩니다.  

  
fetch를 사용하는 요청은 재검증 옵션을 지정하여 요청의 재검증 빈도를 제어할 수 있습니다.   
  
   
   
   ![image](https://github.com/ddp-study/nextjs/assets/99688960/fa4464fd-f6aa-4c75-8f16-c926b4c8d8a1)  
     
     
#### React cache()  

React에서는 캐시()를 사용하여 요청을 중복 제거하고 래핑된 함수 호출의 결과를 메모리에 저장할 수 있습니다.  
동일한 인자로 호출된 동일한 함수는 함수를 다시 실행하는 대신 캐시된 값을 재사용합니다.  

![image](https://github.com/ddp-study/nextjs/assets/99688960/a1bd8a71-29c7-4874-8154-a9785e6ea018)  
  위의 예제에서 getUser() 함수는 두 번 호출되지만 데이터베이스에 대한 쿼리는 한 번만 수행됩니다.  
  이는 getUser()가 cache()로 래핑되어 두 번째 요청에서 첫 번째 요청의 결과를 재사용할 수 있기 때문입니다  
  (첫번째 getUser()의 호출에서 이미 값을 받아와 cache해주어서 두번째 호출에서는 cache된 값만 불러올 수 있다. )  
  
  알아두면 좋습니다:

1. fetch()는 요청을 자동으로 캐시하므로 fetch()를 사용하는 함수를 cache()로 래핑할 필요가 없습니다. 자세한 내용은 자동 요청 중복 제거를 참조하세요.
2. 이 새로운 모델에서는 여러 컴포넌트에서 동일한 데이터를 요청하는 경우에도  
 컴포넌트 간에 데이터를 프롭으로 전달하지 말고 필요한 컴포넌트에서 직접 데이터를 가져오는 것이 좋습니다.
3. 서버 데이터 불러오기 함수가 클라이언트에서 사용되지 않도록 서버 전용 패키지를 사용하는 것이 좋습니다.  

####  GraphQL 및 cache()
fetch를 사용할 때 POST 요청은 자동으로 중복 제거되지 않으며 GET 요청만 중복 제거됩니다.  
GraphQL 및 POST 요청을 사용하는 경우 캐시를 사용하여 요청을 중복 제거할 수 있습니다.  
캐시 인수는 플랫해야 하며 프리미티브만 포함해야 합니다. 딥 객체는 중복 제거를 위해 일치하지 않습니다.  
  ![image](https://github.com/ddp-study/nextjs/assets/99688960/37c86404-1a8b-4daa-9601-f85526733d78)  
#### cache()를 사용한 preload 패턴
패턴으로, 데이터 불러오기를 수행하는 유틸리티 또는 컴포넌트에서 선택적으로 preload() 내보내기를 노출하는 것이 좋습니다.  
![image](https://github.com/ddp-study/nextjs/assets/99688960/0b218397-bff6-44d0-86f3-06b45766720b)  
프리로드를 호출하면 필요한 데이터를 바로 가져올 수 있습니다  
![image](https://github.com/ddp-study/nextjs/assets/99688960/9cf8d293-c8a9-462d-9d45-e84037bbe92a)  
  
  ##### 알아두면 좋습니다:

1.preload() 함수는 어떤 이름이라도  
사용할 수 있습니다. API가 아니라 패턴입니다.
2.이 패턴은 완전히 선택 사항이며 사례별로 최적화하는 데 사용할 수 있습니다.  
3.이 패턴은 병렬 데이터 불러오기에 대한 추가 최적화입니다.   
4.이제 프로미스를 소품으로 전달할 필요가 없으며 대신 프리로드 패턴을 사용할 수 있습니다.   

캐시, 프리로드, 서버 전용 결합하기  
캐시 기능, 프리로드 패턴, 서버 전용 패키지를 결합하여 앱 전체에서 사용할 수 있는 데이터 가져오기 유틸리티를 만들 수 있습니다.


 ![image](https://github.com/ddp-study/nextjs/assets/99688960/1aca74e3-e13b-4cd4-8361-a245a420ab1b)    
 이 접근 방식을 사용하면 데이터를 활발하게 가져오고, 응답을 캐시하며, 이 데이터 가져오기가 서버에서만 발생하도록 보장할 수 있습니다.  

레이아웃, 페이지 또는 컴포넌트에서 getUser.ts 내보내기를 사용하여 사용자 데이터를 가져오는 시기를 제어할 수 있습니다.    
  
#### 세그먼트 수준 캐싱
참고: 캐싱에 대한 세분성 및 제어를 개선하려면 요청별 캐싱을 사용하는 것이 좋습니다.  

세그먼트 수준 캐싱을 사용하면 경로 세그먼트에서 사용된 데이터를 캐싱하고 재검증할 수 있습니다.  

이 메커니즘을 사용하면 경로의 여러 세그먼트가 전체 경로의 캐시 수명을 제어할 수 있습니다.  
경로 계층 구조의 각 page.tsx 및 layout.tsx는 경로의 재검증 시간을 설정하는 재검증 값을 내보낼 수 있습니다.  
![image](https://github.com/ddp-study/nextjs/assets/99688960/05a50dba-ba70-404e-bbc0-de71c9558169)  


 

  
  
  
  

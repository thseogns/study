# 소개 (Introduction)
잘 정의되고 일관된 API뿐만 아닌 재사용 가능한 컴포넌트를 구축하는 것도 소프트웨어 엔지니어링에서의 주요한 부분입니다.  
현재의 데이터와 미래의 데이터 모두를 다룰 수 있는 컴포넌트는 거대한 소프트웨어 시스템을 구성하는 데 있어 가장 유연한 능력을 제공할 것입니다.  

C#과 Java 같은 언어에서, 재사용 가능한 컴포넌트를 생성하는 도구상자의 주요 도구 중 하나는 제네릭입니다,   
즉, 단일 타입이 아닌 다양한 타입에서 작동하는 컴포넌트를 작성할 수 있습니다. 사용자는 제네릭을 통해 여러 타입의 컴포넌트나 자신만의 타입을 사용할 수 있습니다.   
## 제네릭의 Hello World (Hello World of Generics)
제네릭은 이렇게 쓴다.
```.ts  
function identity<T>(arg: T): T {
    return arg;
}
```  
identity 함수에 T라는 타입 변수를 추가했습니다.   
T는 유저가 준 인수의 타입을 캡처하고 (예 - number), 이 정보를 나중에 사용할 수 있게 합니다.   
여기에서는 T를 반환 타입으로 다시 사용합니다. 인수와 반환 타입이 같은 타입을 사용하고 있는 것을 확인할 수 있습니다.   
이를 통해 타입 정보를 함수의 한쪽에서 다른 한쪽으로 운반할 수 있게끔 합니다.  

이 버전의 identity 함수는 타입을 불문하고 동작하므로 제네릭이라 할 수 있습니다.  
any를 쓰는 것과는 다르게 인수와 반환 타입에 number를 사용한 첫 번째 identity 함수만큼 정확합니다.  
(즉, 어떤 정보도 잃지 않습니다)

일단 제네릭 identity 함수를 작성하고 나면, 두 가지 방법 중 하나로 호출할 수 있습니다.  
(아래는 제네릭 호출의 방법이다.)  
첫 번째 방법은 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법입니다.  
```.ts
let output = identity<string>("myString"); // 출력 타입은 'string'입니다.  
```  
여기서 우리는 함수를 호출할 때의 인수 중 하나로써 T를 string으로 명시해 주고 인수 주변에 ```()``` 대신 ```<>```로 감싸주었습니다.  

두 번째 방법은 아마 가장 일반적인 방법입니다. 여기서는 타입 인수 추론 을 사용합니다 -- 즉, 우리가 전달하는 인수에 따라서 컴파일러가 T의 값을 자동으로 정하게 하는 것입니다:     
```.ts
let output = identity("myString"); //출력 타입은 'string'입니다.(자동으로 정하게함.)  

```    
타입 인수를 꺾쇠괄호```(<>)```에 담아 명시적으로 전달해 주지 않은 것을 주목하세요;  
컴파일러는 값인 "myString"를 보고 그것의 타입으로 T를 정합니다. 인수 추론은 코드를 간결하고  
가독성 있게 하는 데 있어 유용하지만 더 복잡한 예제에서 컴파일러가 타입을 유추할 수 없는 경우엔 명시적인 타입 인수 전달이 필요할 수도 있습니다.  
(대충 자체적으로 추론해서 꺽세안에 넣었다는 내용)  
## 제네릭 타입 변수 작업 (Working with Generic Type Variables)
제네릭을 사용하기 시작하면, identity와 같은 제네릭 함수를 만들 때, 컴파일러가 함수 본문에 제네릭 타입화된 매개변수를 쓰도록 강요합니다.  
즉, 이 매개변수들은 실제로 any 나 모든 타입이 될 수 있는 것처럼 취급할 수 있게 됩니다.  


앞에서 본 identity 함수를 살펴보도록 합니다:   
```.ts
function identity<T>(arg: T): T {
  return arg;
}
```  
 함수 호출 시마다 인수 arg의 길이를 로그에 찍으려면 어떻게 해야 합니까? 아마 이것을 쓰고 싶을 겁니다:  
 
```.ts
function loggingIdentity<T>(arg: T): T {
  console.log(arg.length); // 오류: T에는 .length 가 없습니다.
  return arg;
}
```  
이렇게 하면, 컴파일러는 arg의 멤버 .length를 사용하고 있다는 오류를 낼 것입니다만,  
떤 곳에서도 arg가 이 멤버가 있다는 것이 명시되어 있지 않습니다.  
이전에 이러한 변수 타입은 any나 모든 타입을 의미한다고 했던 것을 기억하십시오.   
따라서 이 함수를 쓰고 있는 사용자는 .length 멤버가 없는 number를 대신 전달할 수도 있습니다

실제로 이 함수가 T가 아닌 T의 배열에서 동작하도록 의도했다고 가정해봅시다.   
배열로 사용하기 때문에 .length 멤버는 사용 가능합니다. 다른 타입들의 배열을 만드는 것처럼 표현할 수 있습니다.   
### 제네릭 타입 (Generic Types)
이전 섹션에서 우리는 타입을 초월한 제네릭 함수 identity를 만들었습니다. 이번 섹션에서는 함수 자체의 타입과 제네릭 인터페이스를 만드는 방법에 대해 살펴보겠습니다.

제네릭 함수의 타입은 함수 선언과 유사하게 타입 매개변수가 먼저 나열되는, 비-제네릭 함수의 타입과 비슷합니다.
```.ts
function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: <T>(arg: T) => T = identity; 이게 뭘말하는지? 
```
또한 타입 변수의 수와 타입 변수가 사용되는 방식에 따라 타입의 제네릭 타입 매개변수에 다른 이름을 사용할 수도 있습니다.  
```.ts
function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: <U>(arg: U) => U = identity;
```  
제네릭 타입을 객체 리터럴 타입의 함수 호출 시그니처로 작성할 수도 있습니다:  
```.ts
function identity<T>(arg: T): T {
  return arg;
}

let myIdentity: { <T>(arg: T): T } = identity;
```
이것들로 첫 번째 제네릭 인터페이스를 작성할 수 있습니다. 앞서 예제의 객체 리터럴을 인터페이스로 가져옵니다:  
```.ts
interface GenericIdentityFn {
  <T>(arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}
```  
let myIdentity: GenericIdentityFn = identity;
비슷한 예제에서, 제네릭 매개변수를 전체 인터페이스의 매개변수로 옮기고 싶을지도 모릅니다. 이를 통해 제네릭 타입을 확인할 수 있습니다   
(예 - Dictionary 가 아닌 Dictionary<string>). 이렇게 하면 인터페이스의 다른 모든 멤버가 타입 매개변수를 볼 수 있습니다.  
```.ts
interface GenericIdentityFn<T> {
  (arg: T): T;
}

function identity<T>(arg: T): T {
  return arg;
}
```  
let myIdentity: GenericIdentityFn<number> = identity;
예제에 아주 작은 변화가 있었습니다. 제네릭 함수를 작성하는 것 대신 제네릭 타입의 일부인 비-제네릭 함수 시그니처를 가집니다.  
    GenericIdentityFn 함수를 사용할 때, 시그니처가 사용할 것을 효과적으로 제한할 특정한 타입 인수가 필요합니다 (여기서는 number).  
    타입 매개변수를 호출 시그니처에 바로 넣을 때와 인터페이스 자체에 넣을 때를 이해하는 것은 타입의 제네릭 부분을 설명하는 데 도움이 됩니다.  

제네릭 인터페이스 외에도 제네릭 클래스를 만들 수 있습니다. 제네릭 열거형과 네임스페이스는 만들 수 없습니다.  
